---
title: "Data Analysis with R and Python"
output: html_document
date: "2023-09-27"
---



## PCA


```{r}
library(ade4)
data(deug)
pca1 <- dudi.pca(deug$tab, center = deug$cent, scale = FALSE, scan = FALSE)
pca2 <- dudi.pca(deug$tab, center = TRUE, scale = TRUE, scan = FALSE)
```




The script can be directly usd in Rstudio and R via the R package reticulate (https://rstudio.github.io/reticulate/).

```{r}
write.csv(deug$tab,file="deugtab.csv")
```



# Data importation

see for example: https://www.kaggle.com/code/arnopub/pandas-pr-sentation-des-dataframe

```{python}
import numpy as np 
import pandas as pd
deugtab = pd.read_csv('deugtab.csv')
deugtab
del deugtab['Unnamed: 0']
deugtab
```


# PCA from scratch 

PCA from scratch (https://towardsdatascience.com/principal-component-analysis-from-scratch-in-numpy-61843da1f967)

```{python}
# centering = TRUE
X= deugtab - deugtab.mean()
# Normalize
Z = X / X.std(ddof=0)
print('MEAN:')
print(Z.mean())
print('---'*15)
print('STD:')
print(Z.std(ddof=0))
```

diagonalisation and eigenvectors
```{python}
import numpy as np
len(Z)
ZZ = np.dot(Z.T, Z)/len(Z)
eigenvalues, eigenvectors = np.linalg.eig(ZZ)
D = np.diag(eigenvalues)
P = eigenvectors
Z_new = np.dot(Z, P)
```
valeur propres non ordonnées !!!!

Calculate the proportion of variance explained by each feature
```{python}
sum_eigenvalues = np.sum(eigenvalues)
sum_eigenvalues
prop_var = [i/sum_eigenvalues for i in eigenvalues]
```

Calculate the cumulative variance

```{python}
cum_var = [np.sum(prop_var[:i+1]) for i in range(len(prop_var))]
```

Plot scree plot from PCA
```{python}
import matplotlib.pyplot as plt
x_labels = ['PC{}'.format(i+1) for i in range(len(prop_var))]
plt.plot(x_labels, prop_var, marker='o', markersize=6, color='skyblue', linewidth=2, label='Proportion of variance')
plt.plot(x_labels, cum_var, marker='o', color='orange', linewidth=2, label="Cumulative variance")
plt.legend()
plt.title('Scree plot')
plt.xlabel('Principal components')
plt.ylabel('Proportion of variance')
plt.show()
```


# Collaboration R and python

https://rstudio.github.io/reticulate/


```{r fig.width=8,fig.height=8}
library(reticulate)
library(ade4)
P <- py$P
colnames(P) <- paste("Axis",1:ncol(P),sep="")
rownames(P) <- colnames(py$deugtab)
par(mfrow=c(2,2))
s.corcircle(P,sub="Python version")
s.corcircle(pca2$c1,sub="R version")
plot(P[,1],pca2$c1[,1],panel.first=c(grid()),xlab="Python (axis 1)",ylab="R (axis 1)",pch=19);abline(0,-1,col="red")
plot(P[,2],pca2$c1[,2],panel.first=c(grid()),xlab="Python (axis 2)",ylab="R (axis 2)",pch=19);abline(0,-1,col="red")
```



```{r fig.width=8,fig.height=8}
coordli <- py$Z_new
colnames(coordli) <- paste("CS",1:ncol(coordli),sep="")
rownames(coordli) <- rownames(py$deugtab)
par(mfrow=c(2,2))
s.label(coordli,sub="Python version")
s.label(pca2$li,sub="R version")
plot(coordli[,1],pca2$li[,1],panel.first=c(grid()),xlab="Python (CS 1)",ylab="R (CS 1)",pch=19);abline(0,-1,col="red")
plot(coordli[,2],pca2$li[,2],panel.first=c(grid()),xlab="Python (CS 2)",ylab="R (CS 2)",pch=19);abline(0,-1,col="red")
```

```{r fig.width=10,fig.height=5}
par(mfrow=c(1,2))
plot(py$eigenvalues,pca2$eig,type="b",panel.first=c(grid()),pch=19); abline(0,1,col="red")
plot(sort(py$eigenvalues,decreasing = TRUE),pca2$eig,type="b",panel.first=c(grid()),pch=19); abline(0,1,col="red")
```

problem in the order of the eigenvalues !!!


```{r}
pca2$eig
py$D
py$eigenvalues
```

problem !!!

test of the pca from scikit-learn
```{python}
import sklearn.decomposition as sd
from sklearn.decomposition import PCA
pca = PCA(n_components=9)
Z2 = Z/np.sqrt(104)
pca.fit(Z2)
print(pca.explained_variance_ratio_)
print(pca.singular_values_)
print(pca.singular_values_*pca.singular_values_)
```


# Construction of the function "pydudi"

based on the duality diagram (see more details below)

 * https://pbil.univ-lyon1.fr/R/pdf/tdr61.pdf
 * https://pbil.univ-lyon1.fr/R/pdf/stage3.pdf
 * https://pbil.univ-lyon1.fr/R/pdf/bs8.pdf


first test => need to adjust the weighting (test with COA)

```{python}
import os
import string
import re
import pandas as pd
import numpy as np

def pydudi(X,cw,lw,nf):
  dim = X.shape
  n = dim[0]
  p = dim[1]
  nf0 = nf-1
  # n=len(X)
  # p=len(X.columns)
  D = np.diag(np.sqrt(lw))
  Q = np.diag(np.sqrt(cw))
  
  # XtDXQ => problem  with Q !!!
  
  XD = np.dot(X.T,D).T
  XD = np.dot(XD,Q)
  XtX = np.dot(XD.T,XD)
  
  
  # decomposition
  eigenvalues, eigenvectors = np.linalg.eig(XtX)
  index = np.argsort(eigenvalues)[::-1]
  
  # np.nonzero(eigenvalues)[0]
  
  eigenvalues=eigenvalues[index]
  eigenvectors=eigenvectors[:,index]
  # results
  rank = len(np.nonzero(eigenvalues)[0])
  C1 = np.dot(np.diag(1/np.sqrt(cw)),eigenvectors[:,0:nf])
  #C1 = eigenvectors[:,0:nf]
  XQ = np.dot(X,np.diag(cw))
  Li = np.dot(XQ, C1)
  
  # need to adjust the weighting (problem with sqrt)
  L1 = np.dot(Li,np.diag(1/np.sqrt(eigenvalues[0:nf])))
  Co = np.dot(C1,np.diag(np.sqrt(eigenvalues[0:nf])))
  return eigenvalues,rank,Li,L1,Co,C1,nf;

###
```


```{python}
import numpy as np 
import pandas as pd
deugtab = pd.read_csv('deugtab.csv')
deugtab
del deugtab['Unnamed: 0']
deugtab
X= deugtab - deugtab.mean()
# Normalize
X = X / X.std(ddof=0)
dim = X.shape
n = dim[0]
p = dim[1]
# lw = pd.DataFrame(np.repeat(1/len(X),len(X)))[0]
# cw = pd.DataFrame(np.repeat(1,len(X.columns)))[0]
lw = pd.DataFrame(np.repeat(1/n,n))[0]
cw = pd.DataFrame(np.repeat(1,p))[0]
ted = pydudi(X,cw,lw,2)
```



```{r}
library(reticulate)
names(py$ted) <- c("eig","rank","li","l1","co","c1","nf")
coordli <- py$ted$li
par(mfrow=c(2,2))
s.label(coordli,sub="Python version")
s.label(pca2$li,sub="R version")
plot(coordli[,1],pca2$li[,1],panel.first=c(grid()),xlab="Python (CS 1)",ylab="R (CS 1)",pch=19);abline(0,-1,col="red")
plot(coordli[,2],pca2$li[,2],panel.first=c(grid()),xlab="Python (CS 2)",ylab="R (CS 2)",pch=19);abline(0,-1,col="red")
```

```{r}
coordl1 <- py$ted$l1
par(mfrow=c(2,2))
s.label(coordl1,sub="Python version")
s.label(pca2$l1,sub="R version")
plot(coordl1[,1],pca2$l1[,1],panel.first=c(grid()),xlab="Python (CS 1)",ylab="R (CS 1)",pch=19);abline(0,-1,col="red")
plot(coordl1[,2],pca2$l1[,2],panel.first=c(grid()),xlab="Python (CS 2)",ylab="R (CS 2)",pch=19);abline(0,-1,col="red")
```

```{r fig.height=10,fig.width=10}
par(mfrow=c(2,2))
s.corcircle(py$ted$co,sub="Python version")
s.corcircle(pca2$co,sub="R version")
plot(py$ted$c1[,1],pca2$c1[,1],panel.first=c(grid()),xlab="Python (axis 1)",ylab="R (axis 1)",pch=19);abline(0,-1,col="red")
plot(py$ted$c1[,2],pca2$c1[,2],panel.first=c(grid()),xlab="Python (axis 2)",ylab="R (axis 2)",pch=19);abline(0,-1,col="red")
```

# Test of pydudi with COA

COA: correspondence analysis.

     Benzécri, J.P. and Coll. (1973) _L'analyse des données. II
     L'analyse des correspondances_, Bordas, Paris. 1-620.
     Greenacre, M. J. (1984) _Theory and applications of correspondence
     analysis_, Academic Press, London.


Si R help from ade4 (dudi.coa) and https://pbil.univ-lyon1.fr/R/pdf/stage4.pdf


```{r}
data(rpjdl)
chisq.test(rpjdl$fau)$statistic
rpjdl.coa <- coa1 <- dudi.coa(rpjdl$fau, scannf = FALSE, nf = 4)
sum(rpjdl.coa$eig)*rpjdl.coa$N # the same
```

```{r}
write.csv(rpjdl$fau,file="fau.csv")
```



```{python}
# import numpy as np 
import pandas as pd
fau = pd.read_csv('fau.csv')
fau
del fau['Unnamed: 0']
fau
```



```{python}
import numpy as np

X=fau
sumX = fau.sum().sum()
sumCol =  fau.sum(axis=0)
sumRow = fau.sum(axis=1)

pij = X/sumX
pi = sumRow/sumX
pj = sumCol/sumX

Dj = np.diag(1/pj)
Di = np.diag(1/pi)

Z = np.dot(Di,pij)
Z= np.dot(Z,Dj)
Z.shape
Z =Z - 1
Z = np.nan_to_num(Z)

# Normalize
lw = pi
cw = pj
D= np.diag(np.sqrt(pi))
Q= np.diag(np.sqrt(pj))
X =Z
ted = pydudi(Z,cw,lw,2)
```


```{r}
require(reticulate)
names(py$ted) <- c("eig","rank","li","l1","co","c1","nf")
```



```{r}
head(t(t(py$X)%*%py$D))[,1]
head(py$X*diag(py$D))[,1]
```


```{r}
XD <- t(t(py$X)%*%py$D)
head(XD%*%py$Q)[,1]
head(sweep(XD,2,diag(py$Q),"*"))[,1]
```

```{r}
coa1$eig
py$ted$eig
```


ok for the eigenvalues, probleme dans le calcul des coordonnées ???

```{r}
coordli <- py$ted$li
par(mfrow=c(2,2))
s.label(coordli,sub="Python version")
s.label(coa1$li,sub="R version")
plot(coordli[,1],coa1$li[,1],panel.first=c(grid()),xlab="Python (CS 1)",ylab="R (CS 1)",pch=19);abline(0,-1,col="red")
plot(coordli[,2],coa1$li[,2],panel.first=c(grid()),xlab="Python (CS 2)",ylab="R (CS 2)",pch=19);abline(0,-1,col="red")
```

```{r}
coordl1 <- py$ted$l1
par(mfrow=c(2,2))
s.label(coordl1,sub="Python version")
s.label(coa1$l1,sub="R version")
plot(coordl1[,1],coa1$l1[,1],panel.first=c(grid()),xlab="Python (CS 1)",ylab="R (CS 1)",pch=19);abline(0,-1,col="red")
plot(coordl1[,2],coa1$l1[,2],panel.first=c(grid()),xlab="Python (CS 2)",ylab="R (CS 2)",pch=19);abline(0,-1,col="red")
```

```{r fig.height=10,fig.width=10}
par(mfrow=c(2,2))
plot(py$Z[,1],coa1$tab[,1],panel.first=c(grid()),xlab="Python (col 1 of Z)",ylab="R (col 1 of tab)",pch=19);abline(0,1,col="red")
plot(py$ted$c1[,1],coa1$c1[,1],panel.first=c(grid()),xlab="Python (normed Axis 1)",ylab="R (normed Axis 1)",pch=19);abline(0,-1,col="red")
plot(py$ted$co[,1],coa1$co[,1],panel.first=c(grid()),xlab="Python (Axis 1)",ylab="R (Axis 1)",pch=19);abline(0,-1,col="red")
```


=> need to check the weight !!! => Ok !!



